/*
 * =============================================================================
 * Project: FlowShift - The Sovereign Content Engine
 * Component: MarkdownLinter
 * 
 * Copyright (c) 2026 FlowShift. All rights reserved.
 * Author: Henryk Daniel Zschuppan
 *
 * This source code is proprietary and confidential. Unauthorized copying 
 * of this file, via any medium, is strictly prohibited.
 *
 * DESIGN PHILOSOPHY: High-performance, context-aware structural validation
 * utilizing a single-pass Oracle-Backtick-Protocol for real-time processing.
 * =============================================================================
 */

package com.flowshift.editor.webview;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Sovereign Source Mapper v10.2
 * 
 * Central cartography engine responsible for bidirectional synchronization between the rendered WebView and the Markdown source code. This class injects unique identifiers into
 * the rendered HTML to map back to the exact character offset in the source editor.
 * 
 * CORE RESPONSIBILITIES: 1. ID Injection: Injects unique 'data-fs-id' attributes into every processable HTML tag. 2. Offset Indexing: Builds a high-speed lookup map (O(1)) linking
 * IDs to exact character offsets. 3. Hybrid Strategy: Uses the Flexmark 'data-line' attribute as a preliminary anchor point.
 */
public class SovereignSourceMapper {

	// --- CONSTANTS: CONFIGURATION & NAMING ---
	
		/** The core attribute name injected into the HTML for tracking elements. */
		public  static final String FLOWSHIFT_ID_NAME   = "fsid";     
		/** The attribute name provided by Flexmark for line anchoring. */
		public static final String DATA_LINE_ATTRIBUTE = "data-line";
		/** Constant string used for attribute value separation. */
		private static final String ATTRIBUTE_SEPARATOR = "=\"";

		// --- CONSTANTS: SEARCH THRESHOLDS ---

		/** Maximum search distance (in characters) when scanning the editor text for raw HTML tags (Stage 2). */
		private static final int MAX_HTML_SEARCH_DISTANCE = 500;
		/** Maximum search distance (in characters) when scanning for text snippets (Stage 3). */
		private static final int MAX_TEXT_SEARCH_DISTANCE = 1000; 
		/** Minimum length required for a text snippet to be considered for matching (Stage 3). */
		private static final int MIN_SNIPPET_LENGTH       = 2;    

		// --- REGEX PATTERNS ---
		
		/** Pattern to capture the full tag structure: (1:Full Open Tag) (2:Tag Name) (3:Attributes) (4:Text Content). */
		private static final Pattern TAG_AND_TEXT_PATTERN = Pattern.compile("(<([a-zA-Z0-9]+)(\\s+[^>]*?)?>)([^<]*)");
		/** Pattern to extract the line number from the Flexmark-injected data-line attribute. */
		private static final Pattern DATA_LINE_PATTERN    = Pattern.compile(DATA_LINE_ATTRIBUTE + "=\"(\\d+)");

		// --- STATE ---
		
		/** High-speed lookup map: Maps the injected ID (string) to the character offset (integer) in the source text. */
		private final Map<String, Integer> idToOffsetMap = new HashMap<>();
		/** Counter used to generate unique, sequential FlowShift IDs. */
		private int                        idCounter     = 0;

	/**
	 * Scans the raw HTML output from Flexmark, injects unique IDs (data-fs-id), and maps these IDs to the most probable character offset in the source editor text.
	 * 
	 * @param rawHtml    The HTML output generated by the Flexmark renderer.
	 * @param editorText The complete source Markdown text from the editor.
	 * @return The mutated HTML string with 'data-fs-id' attributes injected.
	 */
	public String mapAndInject(String rawHtml, String editorText) {
		idToOffsetMap.clear();
		idCounter = 0;

		StringBuilder sb = new StringBuilder();
		Matcher m = TAG_AND_TEXT_PATTERN.matcher(rawHtml);

		int lastHtmlPos = 0;
		int lastEditorPos = 0; // The last confirmed editor position (to prevent scanning backward)
		int currentAnchorOffset = 0; // The safest offset determined so far

		while (m.find()) {
			sb.append(rawHtml, lastHtmlPos, m.start());

			String tagName = m.group(2);
			String attributes = m.group(3) != null ? m.group(3) : "";
			String textAfter = m.group(4).trim();

			String fsid = String.valueOf(idCounter++);
			int sourceOffset = -1;
			boolean offsetFound = false;

			// --- STAGE 1: FLEXMARK GROUNDING (Data-Line Attribute) ---
			Matcher lineMatcher = DATA_LINE_PATTERN.matcher(attributes);
			if (lineMatcher.find()) {
				int lineOffset = Integer.parseInt(lineMatcher.group(1));
				sourceOffset = lineOffset;
				offsetFound = true;
			}

			// --- STAGE 2: HTML SOVEREIGNTY (Search for Raw Tags) ---
			if (!offsetFound) {
				int foundTag = indexOfIgnoreCase(editorText, "<" + tagName, lastEditorPos);
				if (foundTag != -1 && (foundTag - lastEditorPos) < MAX_HTML_SEARCH_DISTANCE) {
					sourceOffset = foundTag;
					offsetFound = true;
				}
			}

			// --- STAGE 3: SEMANTIC TEXT-MATCH (Anchor for Inlines) ---
			if (!offsetFound) {
				if (!textAfter.isEmpty() && textAfter.length() > MIN_SNIPPET_LENGTH) {
					String snippet = textAfter.substring(0, Math.min(textAfter.length(), 20));
					int foundText = indexOfIgnoreCase(editorText, snippet, lastEditorPos);

					if (foundText != -1 && (foundText - lastEditorPos) < MAX_TEXT_SEARCH_DISTANCE) {
						sourceOffset = foundText;
						offsetFound = true;
					}
				}
			}

			// --- FINALISIERUNG & SPEICHER-HEILUNG ---
			if (!offsetFound) {
				// Fallback: Wenn absolut nichts gefunden wurde, erbe vom letzten Anker.
				sourceOffset = currentAnchorOffset;
			} else {
				// HEILUNG: Wir haben einen neuen Offset gefunden!
				// 1. Stelle sicher, dass wir nicht rückwärts springen.
				sourceOffset = Math.max(sourceOffset, lastEditorPos);
				// 2. Verankere den neuen Fortschritt im Gedächtnis.
				lastEditorPos = sourceOffset;
				currentAnchorOffset = sourceOffset;
			}

			// MAP & INJECT
			idToOffsetMap.put(fsid, sourceOffset);
            sb.append(formatTag(tagName, fsid, attributes));
			lastHtmlPos = m.end(1);
		}

		// Append any remaining HTML content after the last matched tag
		sb.append(rawHtml.substring(lastHtmlPos));
		return sb.toString();
	}


	/**
	 * Formats and constructs the final HTML opening tag by efficiently injecting the data-fsid attribute while preserving the original attributes (data-line).
	 * 
	 * @param tagName    The original HTML tag name (e.g., "p", "div").
	 * @param fsId       The unique ID value to inject (e.g., "123").
	 * @param attributes The original attributes string (e.g., ' data-line="15"').
	 * @return The final, valid HTML opening tag string.
	 */
	private String formatTag(String tagName, String fsId, String attributes) {
		// Wir nutzen StringBuilder für die performante Konkatenation innerhalb der Methode.
		StringBuilder tagBuilder = new StringBuilder(64); // Typische Startkapazität

		tagBuilder.append("<").append(tagName).append(" data-").append(FLOWSHIFT_ID_NAME).append(ATTRIBUTE_SEPARATOR).append(fsId).append("\"").append(attributes).append(">");

		return tagBuilder.toString();
	}

	/**
	 * Performs a case-insensitive search for a target substring within a source string, starting from a given index.
	 */
	private int indexOfIgnoreCase(String source, String target, int fromIndex) {
		if (target.isEmpty())
			return fromIndex;
		for (int i = fromIndex; i <= source.length() - target.length(); i++) {
			if (source.regionMatches(true, i, target, 0, target.length())) {
				return i;
			}
		}
		return -1;
	}

	/**
	 * Retrieves the corresponding character offset in the Markdown source for a given FlowShift ID (data-fs-id) found in the rendered HTML.
	 * 
	 * @param fsId The FlowShift ID extracted from the WebView DOM element.
	 * @return The zero-based character offset in the Markdown editor, or -1 if the ID is not found.
	 */
	public int getOffsetForFsId(String fsId) {
		return idToOffsetMap.getOrDefault(fsId, -1);
	}
}

